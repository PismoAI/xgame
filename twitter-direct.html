<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitter Original Game (Standard Controls)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        canvas { 
            display: block; 
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #menuBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #0088ff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 10000;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
        }
        #loadingText {
            font-size: 24px;
            margin-bottom: 20px;
        }
        #progressBar {
            width: 300px;
            height: 10px;
            border-radius: 5px;
            background-color: #333;
            overflow: hidden;
            margin-bottom: 30px;
        }
        #progressFill {
            height: 100%;
            width: 0%;
            background-color: #0088ff;
            transition: width 0.3s;
        }
        #backButton {
            background-color: #ff3333;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingText">Loading Twitter Original Game (Standard Controls)...</div>
        <div id="progressBar"><div id="progressFill"></div></div>
        <button id="backButton" onclick="window.location.href='/'">BACK TO MENU</button>
    </div>
    
    <div id="instructions">
        W - Move Forward<br>
        S - Move Backward<br>
        A - Move Left<br>
        D - Move Right<br>
        Mouse - Look around<br>
        Space - Jump
    </div>
    
    <button id="menuBtn" onclick="window.location.href='/'">BACK TO MENU</button>
    
    <!-- Load the character controller script -->
    <script src="character-controller.js"></script>
    
    <script>
        // Show loading screen with progress
        const loadingScreen = document.getElementById('loadingScreen');
        const progressFill = document.getElementById('progressFill');
        const loadingText = document.getElementById('loadingText');
        
        function updateProgress(percent, message) {
            progressFill.style.width = percent + '%';
            if (message) {
                loadingText.innerText = message;
            }
        }
        
        // Start with 0% progress
        updateProgress(0, "Initializing...");
        
        // Load Three.js from CDN
        const threeScript = document.createElement('script');
        threeScript.src = "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js";
        document.head.appendChild(threeScript);
        
        threeScript.onload = function() {
            updateProgress(20, "Three.js loaded");
            
            // Load PointerLockControls
            const controlsScript = document.createElement('script');
            controlsScript.src = "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js";
            document.head.appendChild(controlsScript);
            
            controlsScript.onload = function() {
                updateProgress(40, "Controls loaded");
                
                // Now load the game script
                setTimeout(() => {
                    updateProgress(60, "Preparing game environment...");
                    
                    // Add the game script
                    const gameScript = document.createElement('script');
                    gameScript.innerHTML = `
                        // Global variables
                        let camera, scene, renderer, controls;
                        let terrain;
                        let velocity = new THREE.Vector3();
                        let direction = new THREE.Vector3();
                        let prevTime = performance.now();
                        let raycaster;
                        let character;
                        let jumpCount = 0;
                        let sun;
                        let sunSphere, sunGlow; // Add global sun object variables
                        const maxJumps = 5;
                        let vertices;  // Make vertices global
                        let clouds = []; // Make clouds global

                        // Gamepad variables
                        let gamepad = null;
                        let gamepadConnected = false;
                        const deadzone = 0.15;
                        const lookSensitivity = 3.0;
                        const maxLookSpeed = Math.PI * 2;
                        let prevAButtonPressed = false;  // Track previous A button state

                        // Add gamepad connection handlers
                        window.addEventListener("gamepadconnected", (e) => {
                            console.log("Gamepad connected:", e.gamepad);
                            gamepadConnected = true;
                            gamepad = e.gamepad;
                        });

                        window.addEventListener("gamepaddisconnected", (e) => {
                            console.log("Gamepad disconnected:", e.gamepad);
                            gamepadConnected = false;
                            gamepad = null;
                        });

                        // Function to handle gamepad input
                        function handleGamepad(delta) {
                            // Get latest gamepad state
                            const gamepads = navigator.getGamepads();
                            if (!gamepads) return;
                            
                            const gamepad = gamepads[0]; // Use first gamepad
                            if (!gamepad) return;

                            // Left stick movement (axes[0] is left/right, axes[1] is up/down)
                            const leftX = Math.abs(gamepad.axes[0]) > deadzone ? gamepad.axes[0] : 0;
                            const leftY = Math.abs(gamepad.axes[1]) > deadzone ? gamepad.axes[1] : 0;

                            // Right stick camera control (axes[2] is left/right, axes[3] is up/down)
                            const rightX = Math.abs(gamepad.axes[2]) > deadzone ? gamepad.axes[2] : 0;
                            const rightY = Math.abs(gamepad.axes[3]) > deadzone ? gamepad.axes[3] : 0;

                            // Handle A button jumping with state tracking
                            const aButtonPressed = gamepad.buttons[0].pressed;
                            if (aButtonPressed && !prevAButtonPressed) {  // Only jump on button press, not hold
                                if (isOnGround()) {
                                    velocity.y = jumpForce;
                                    jumpCount = 1;
                                } else if (jumpCount < maxJumps) {
                                    velocity.y = jumpForce;
                                    jumpCount++;
                                }
                            }
                            prevAButtonPressed = aButtonPressed;  // Update previous state

                            // Handle right stick camera movement
                            if (rightX !== 0 || rightY !== 0) {
                                // Get current camera rotation
                                const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                                euler.setFromQuaternion(camera.quaternion);

                                // Horizontal camera rotation (yaw) - only affects Y axis
                                if (rightX !== 0) {
                                    euler.y -= rightX * lookSensitivity * delta;
                                }

                                // Vertical camera rotation (pitch) - only affects X axis
                                if (rightY !== 0) {
                                    // Calculate new pitch
                                    euler.x = Math.max(
                                        -Math.PI / 2,  // Looking up limit
                                        Math.min(
                                            Math.PI / 2,  // Looking down limit
                                            euler.x - (rightY * lookSensitivity * delta)
                                        )
                                    );
                                }

                                // Always keep Z rotation (roll) at 0
                                euler.z = 0;

                                // Apply the rotation
                                camera.quaternion.setFromEuler(euler);
                            }

                            // Apply left stick movement with improved vector handling
                            if (leftX !== 0 || leftY !== 0) {
                                // Get camera's forward and right vectors
                                const forward = new THREE.Vector3(0, 0, -1);
                                forward.applyQuaternion(camera.quaternion);
                                forward.y = 0;  // Keep movement horizontal
                                forward.normalize();
                                
                                const right = new THREE.Vector3(1, 0, 0);
                                right.applyQuaternion(camera.quaternion);
                                right.y = 0;  // Keep movement horizontal
                                right.normalize();

                                // Calculate movement vector
                                const moveVector = new THREE.Vector3();
                                moveVector.addScaledVector(forward, -leftY);
                                moveVector.addScaledVector(right, leftX);
                                
                                if (moveVector.length() > 0) {
                                    moveVector.normalize();
                                    moveVector.multiplyScalar(moveSpeed * delta);
                                    
                                    // Apply movement to camera position
                                    camera.position.add(moveVector);
                                    
                                    // Update character rotation to face movement direction
                                    const targetAngle = Math.atan2(moveVector.x, moveVector.z);
                                    const currentAngle = character.rotation.y;
                                    character.rotation.y = currentAngle + (targetAngle - currentAngle) * 0.15;
                                }
                            }
                        }

                        const moveSpeed = 100.0;
                        const jumpForce = 60;
                        const objects = [];
                        const characterHeight = 10;

                        // Define critical functions first
                        function getHeightAt(x, z) {
                            // More accurate height calculation
                            const size = 2000; // Total terrain size
                            const segments = 128; // Number of segments
                            const gridSize = size / segments;

                            // Convert world coordinates to grid coordinates
                            const halfSize = size / 2;
                            const gridX = Math.floor((x + halfSize) / gridSize);
                            const gridZ = Math.floor((z + halfSize) / gridSize);

                            // Ensure we're within bounds of the terrain
                            if (gridX < 0 || gridX >= segments || gridZ < 0 || gridZ >= segments) {
                                return 0;
                            }

                            // Get the four corners of the grid cell
                            const index = (gridZ * (segments + 1) + gridX) * 3;
                            
                            // Check if vertices is defined and index is valid
                            if (!vertices || index < 0 || index + 3 >= vertices.length || 
                                index + ((segments + 1) * 3) >= vertices.length || 
                                index + ((segments + 1) * 3) + 3 >= vertices.length) {
                                return 0;
                            }
                            
                            const y1 = vertices[index + 1];
                            const y2 = vertices[index + 3 + 1];
                            const y3 = vertices[index + ((segments + 1) * 3) + 1];
                            const y4 = vertices[index + ((segments + 1) * 3) + 3 + 1];

                            // Calculate the position within the grid cell (0 to 1)
                            const percentX = ((x + halfSize) % gridSize) / gridSize;
                            const percentZ = ((z + halfSize) % gridSize) / gridSize;

                            // Bilinear interpolation for smoother height transitions
                            const topHeight = y1 * (1 - percentX) + y2 * percentX;
                            const bottomHeight = y3 * (1 - percentX) + y4 * percentX;
                            return topHeight * (1 - percentZ) + bottomHeight * percentZ;
                        }

                        function getTerrainHeight(x, z) {
                            return getHeightAt(x, z);
                        }

                        function isOnGround() {
                            const terrainY = getHeightAt(camera.position.x, camera.position.z);
                            return Math.abs(camera.position.y - (terrainY + characterHeight)) < 0.5;
                        }

                        // Function to create diverse world objects
                        function createWorldObject(type, x, z) {
                            const height = getHeightAt(x, z);
                            let object;

                            switch(type) {
                                case 'tallTree':
                                    const trunkHeight = 15 + Math.random() * 10;
                                    const trunk = new THREE.Mesh(
                                        new THREE.CylinderGeometry(1.2, 1.8, trunkHeight, 8),
                                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                                    );
                                    const leaves1 = new THREE.Mesh(
                                        new THREE.ConeGeometry(6, trunkHeight * 0.7, 8),
                                        new THREE.MeshStandardMaterial({ color: 0x2D5F15 })
                                    );
                                    const leaves2 = new THREE.Mesh(
                                        new THREE.ConeGeometry(4, trunkHeight * 0.5, 8),
                                        new THREE.MeshStandardMaterial({ color: 0x2D5F15 })
                                    );
                                    leaves1.position.y = trunkHeight * 0.6;
                                    leaves2.position.y = trunkHeight * 0.9;
                                    trunk.add(leaves1);
                                    trunk.add(leaves2);
                                    object = trunk;
                                    break;

                                case 'deadTree':
                                    const deadTreeHeight = 12 + Math.random() * 15;
                                    const deadTrunk = new THREE.Mesh(
                                        new THREE.CylinderGeometry(0.8, 1.5, deadTreeHeight, 6),
                                        new THREE.MeshStandardMaterial({ 
                                            color: 0x4A3728,
                                            roughness: 1.0,
                                            metalness: 0.0
                                        })
                                    );
                                    deadTrunk.rotation.z = (Math.random() - 0.5) * 0.3;
                                    
                                    const branchCount = 3 + Math.floor(Math.random() * 4);
                                    for (let i = 0; i < branchCount; i++) {
                                        const branch = new THREE.Mesh(
                                            new THREE.CylinderGeometry(0.4, 0.8, 4 + Math.random() * 8, 5),
                                            new THREE.MeshStandardMaterial({ color: 0x4A3728 })
                                        );
                                        branch.position.y = deadTreeHeight * (0.3 + i * 0.2);
                                        branch.rotation.z = (Math.random() - 0.5) * Math.PI * 0.7;
                                        branch.rotation.y = Math.random() * Math.PI * 2;
                                        deadTrunk.add(branch);
                                    }
                                    object = deadTrunk;
                                    break;

                                case 'wideTree':
                                    const wideTreeHeight = 12 + Math.random() * 8;
                                    const wideTrunk = new THREE.Mesh(
                                        new THREE.CylinderGeometry(1.5, 2.2, wideTreeHeight, 8),
                                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                                    );
                                    
                                    const foliageLayers = 3;
                                    const baseWidth = 12;
                                    const baseHeight = wideTreeHeight * 0.4;
                                    
                                    for (let i = 0; i < foliageLayers; i++) {
                                        const layerWidth = baseWidth - (i * 2);
                                        const layerHeight = baseHeight - (i * 2);
                                        const yOffset = wideTreeHeight * (0.5 + i * 0.15);
                                        
                                        const foliage = new THREE.Mesh(
                                            new THREE.ConeGeometry(layerWidth, layerHeight, 8),
                                            new THREE.MeshStandardMaterial({ color: 0x355E1C })
                                        );
                                        foliage.position.y = yOffset;
                                        foliage.rotation.y = Math.random() * Math.PI * 2;
                                        wideTrunk.add(foliage);
                                    }
                                    object = wideTrunk;
                                    break;

                                case 'mysticalTree':
                                    const mysticalTreeHeight = 15 + Math.random() * 10;
                                    const mysticalTrunk = new THREE.Mesh(
                                        new THREE.CylinderGeometry(0.8, 1.2, mysticalTreeHeight, 8),
                                        new THREE.MeshStandardMaterial({ 
                                            color: 0x4A2F48,  // Deep purple-brown
                                            roughness: 0.7,
                                            metalness: 0.3
                                        })
                                    );
                                    
                                    // Add spiral pattern around trunk
                                    const spiralCount = 5;
                                    for (let i = 0; i < spiralCount; i++) {
                                        const spiralHeight = mysticalTreeHeight * 0.8;
                                        const turns = 3;
                                        for (let j = 0; j < 12; j++) {
                                            const glowOrb = new THREE.Mesh(
                                                new THREE.SphereGeometry(0.3, 8, 8),
                                                new THREE.MeshStandardMaterial({ 
                                                    color: 0x88ffff,
                                                    emissive: 0x44dddd,
                                                    emissiveIntensity: 0.5,
                                                    transparent: true,
                                                    opacity: 0.8
                                                })
                                            );
                                            const angle = (j / 12) * Math.PI * 2 * turns + (i * Math.PI * 0.4);
                                            const height = (j / 12) * spiralHeight;
                                            glowOrb.position.set(
                                                Math.cos(angle) * 1.5,
                                                height,
                                                Math.sin(angle) * 1.5
                                            );
                                            mysticalTrunk.add(glowOrb);
                                        }
                                    }
                                    
                                    // Add mystical foliage
                                    const foliageLevels = 4;
                                    for (let i = 0; i < foliageLevels; i++) {
                                        const scale = 1 - (i * 0.2);
                                        const mysticalFoliage = new THREE.Mesh(
                                            new THREE.IcosahedronGeometry(4 * scale, 1),
                                            new THREE.MeshStandardMaterial({ 
                                                color: 0x88AA99,
                                                emissive: 0x225544,
                                                emissiveIntensity: 0.2,
                                                transparent: true,
                                                opacity: 0.9
                                            })
                                        );
                                        mysticalFoliage.position.y = mysticalTreeHeight * (0.6 + i * 0.15);
                                        mysticalFoliage.rotation.y = Math.random() * Math.PI * 2;
                                        mysticalTrunk.add(mysticalFoliage);
                                    }
                                    
                                    object = mysticalTrunk;
                                    break;

                                case 'palmTree':
                                    object = new THREE.Group();
                                    const palmHeight = 15 + Math.random() * 10;
                                    const segments = 8;
                                    const points = [];
                                    
                                    for (let i = 0; i <= segments; i++) {
                                        const y = (i / segments) * palmHeight;
                                        const curve = Math.sin((i / segments) * Math.PI * 0.5) * 2;
                                        points.push(new THREE.Vector3(curve, y, 0));
                                    }
                                    
                                    const palmTrunk = new THREE.Mesh(
                                        new THREE.TubeGeometry(
                                            new THREE.CatmullRomCurve3(points),
                                            segments,
                                            0.8,
                                            8,
                                            false
                                        ),
                                        new THREE.MeshStandardMaterial({ color: 0x8B5E3C })
                                    );
                                    object.add(palmTrunk);
                                    
                                    const frondCount = 12;
                                    for (let i = 0; i < frondCount; i++) {
                                        const frond = new THREE.Mesh(
                                            new THREE.PlaneGeometry(8, 1),
                                            new THREE.MeshStandardMaterial({ 
                                                color: 0x2D5F15,
                                                side: THREE.DoubleSide
                                            })
                                        );
                                        frond.position.y = palmHeight - 1;
                                        frond.rotation.y = (i / frondCount) * Math.PI * 2;
                                        frond.rotation.x = Math.PI / 4;
                                        object.add(frond);
                                    }
                                    break;

                                case 'crystal':
                                    const crystalSize = 2 + Math.random() * 3;
                                    object = new THREE.Mesh(
                                        new THREE.OctahedronGeometry(crystalSize, 0),
                                        new THREE.MeshStandardMaterial({ 
                                            color: 0x88ffff,
                                            metalness: 0.9,
                                            roughness: 0.2,
                                            transparent: true,
                                            opacity: 0.8
                                        })
                                    );
                                    break;

                                case 'mushroom':
                                    const stem = new THREE.Mesh(
                                        new THREE.CylinderGeometry(0.5, 0.7, 2, 8),
                                        new THREE.MeshStandardMaterial({ color: 0xE8E0D5 })
                                    );
                                    const cap = new THREE.Mesh(
                                        new THREE.SphereGeometry(2, 8, 8),
                                        new THREE.MeshStandardMaterial({ color: 0xFF4444 })
                                    );
                                    cap.scale.y = 0.5;
                                    cap.position.y = 1.5;
                                    stem.add(cap);
                                    object = stem;
                                    break;

                                case 'boulder':
                                    const size = 3 + Math.random() * 5;
                                    object = new THREE.Mesh(
                                        new THREE.DodecahedronGeometry(size, 1),
                                        new THREE.MeshStandardMaterial({ 
                                            color: 0x666666,
                                            roughness: 0.8,
                                            metalness: 0.2
                                        })
                                    );
                                    break;

                                case 'npc':
                                    object = new THREE.Group();
                                    const npcType = arguments[3] || 'jedi';
                                    const npcColor = {
                                        'jedi': 0x4287f5,
                                        'rebel': 0xff4422,
                                        'merchant': 0xffaa00,
                                        'droid': 0xcccccc
                                    }[npcType] || 0x4287f5;
                                    
                                    const npcBody = new THREE.Mesh(
                                        new THREE.CylinderGeometry(1, 1, 6, 8),
                                        new THREE.MeshStandardMaterial({ color: npcColor })
                                    );
                                    object.add(npcBody);
                                    
                                    const head = new THREE.Mesh(
                                        new THREE.SphereGeometry(1.2, 8, 8),
                                        new THREE.MeshStandardMaterial({ color: npcColor })
                                    );
                                    head.position.y = 4;
                                    object.add(head);

                                    object.userData.type = 'npc';
                                    object.userData.npcType = npcType;
                                    break;
                            }

                            if (object) {
                                object.position.set(x, height, z);
                                object.rotation.y = Math.random() * Math.PI * 2;
                                object.castShadow = true;
                                object.receiveShadow = true;
                                scene.add(object);
                                objects.push(object);
                                return object;
                            }
                        }

                        // Initialize after resources are loaded
                        updateProgress(70, "Building world...");
                        init();
                        animate();

                        function init() {
                            // Create scene with enhanced atmosphere
                            scene = new THREE.Scene();
                            scene.background = new THREE.Color(0x88bbff);
                            scene.fog = new THREE.FogExp2(0x88bbff, 0.0008);

                            // Create camera
                            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
                            camera.position.y = characterHeight;

                            // Create renderer with enhanced settings
                            renderer = new THREE.WebGLRenderer({ 
                                antialias: true,
                                powerPreference: "high-performance"
                            });
                            renderer.setPixelRatio(window.devicePixelRatio);
                            renderer.setSize(window.innerWidth, window.innerHeight);
                            renderer.shadowMap.enabled = true;
                            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                            renderer.outputEncoding = THREE.sRGBEncoding;
                            renderer.toneMapping = THREE.ACESFilmicToneMapping;
                            renderer.toneMappingExposure = 1.0;
                            document.body.appendChild(renderer.domElement);

                            // Load grass textures AFTER renderer is created
                            const textureLoader = new THREE.TextureLoader();
                            
                            // Create grass texture with fallback color if texture fails to load
                            const grassTexture = textureLoader.load(
                                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg',
                                undefined,
                                undefined,
                                function(err) {
                                    console.log('Error loading grass texture, using fallback');
                                    terrain.material.map = null;
                                    terrain.material.color.setHex(0x3A7E4B);
                                }
                            );
                            
                            if (grassTexture) {
                                grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
                                grassTexture.repeat.set(50, 50);
                                grassTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                            }
                            
                            // Create normal map for grass with fallback if texture fails to load
                            const grassNormal = textureLoader.load(
                                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-normal.jpg',
                                undefined,
                                undefined,
                                function(err) {
                                    console.log('Error loading normal map, using fallback');
                                    terrain.material.normalMap = null;
                                }
                            );
                            
                            if (grassNormal) {
                                grassNormal.wrapS = grassNormal.wrapT = THREE.RepeatWrapping;
                                grassNormal.repeat.set(50, 50);
                            }

                            // Enhanced lighting system with better values
                            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Increased intensity
                            scene.add(ambientLight);

                            // Main sunlight with enhanced shadows
                            sun = new THREE.DirectionalLight(0xfffaf0, 2.0);
                            sun.position.set(0, 1000, 0);
                            sun.castShadow = true;
                            
                            // Improve shadow quality
                            sun.shadow.mapSize.width = 2048;
                            sun.shadow.mapSize.height = 2048;
                            sun.shadow.camera.near = 0.1;
                            sun.shadow.camera.far = 3000;
                            sun.shadow.camera.left = -500;
                            sun.shadow.camera.right = 500;
                            sun.shadow.camera.top = 500;
                            sun.shadow.camera.bottom = -500;
                            sun.shadow.bias = -0.0001;
                            sun.shadow.normalBias = 0.02;
                            sun.shadow.radius = 1;
                            scene.add(sun);
                            scene.add(sun.target);

                            // Add visible sun sphere with adjusted size
                            const sunGeometry = new THREE.SphereGeometry(100, 32, 32);
                            const sunMaterial = new THREE.MeshBasicMaterial({
                                color: 0xffff00,
                                transparent: true,
                                opacity: 1
                            });
                            sunSphere = new THREE.Mesh(sunGeometry, sunMaterial);
                            sunSphere.position.copy(sun.position);
                            scene.add(sunSphere);

                            // Add sun glow effect
                            const sunGlowGeometry = new THREE.SphereGeometry(120, 32, 32);
                            const sunGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0xffff44,
                                transparent: true,
                                opacity: 0.3
                            });
                            sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
                            sunSphere.add(sunGlow);

                            // Add lens flare
                            const sunFlareGeometry = new THREE.PlaneGeometry(200, 200);
                            const sunFlareMaterial = new THREE.MeshBasicMaterial({
                                color: 0xffffff,
                                transparent: true,
                                opacity: 0.6,
                                side: THREE.DoubleSide,
                                blending: THREE.AdditiveBlending
                            });
                            const sunFlare = new THREE.Mesh(sunFlareGeometry, sunFlareMaterial);
                            sunSphere.add(sunFlare);
                            sunFlare.lookAt(camera.position);

                            // Make sunFlare a global variable
                            window.sunFlare = sunFlare;

                            updateProgress(75, "Adding lighting effects...");
                            
                            // Add multiple atmospheric lights for better environment lighting
                            const secondaryLight = new THREE.DirectionalLight(0xb0c4de, 0.8);
                            secondaryLight.position.set(-50, 100, -50);
                            secondaryLight.castShadow = true;
                            secondaryLight.shadow.mapSize.width = 1024;
                            secondaryLight.shadow.mapSize.height = 1024;
                            scene.add(secondaryLight);

                            const hemiLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.6);
                            scene.add(hemiLight);

                            updateProgress(80, "Creating player character...");
                            
                            // Create character
                            const characterGeometry = new THREE.CylinderGeometry(1, 1, 4, 8);
                            const characterMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x3d3d3d,
                                roughness: 0.7,
                                metalness: 0.1
                            });
                            character = new THREE.Mesh(characterGeometry, characterMaterial);
                            character.castShadow = true;
                            character.receiveShadow = true;
                            character.position.y = characterHeight;
                            scene.add(character);

                            // Setup controls with proper configuration
                            raycaster = new THREE.Raycaster();
                            controls = new THREE.PointerLockControls(camera, document.body);
                            controls.pointerSpeed = 1.0; // Adjust if needed for mouse sensitivity

                            document.addEventListener('click', function () {
                                controls.lock();
                            });

                            updateProgress(85, "Generating terrain...");
                            
                            // Create terrain
                            const geometry = new THREE.PlaneGeometry(2000, 2000, 128, 128);
                            geometry.rotateX(-Math.PI / 2);
                            terrain = new THREE.Mesh(
                                geometry,
                                new THREE.MeshStandardMaterial({ 
                                    color: 0x3A7E4B,
                                    roughness: 0.8,
                                    metalness: 0.2,
                                    wireframe: false,
                                    side: THREE.DoubleSide
                                })
                            );
                            scene.add(terrain);

                            // Create clouds
                            const cloudLayers = [
                                { count: 8, height: 150, speed: 0.05, spread: 40, size: 3, opacity: 0.7 },  // High clouds
                                { count: 12, height: 120, speed: 0.08, spread: 30, size: 2.5, opacity: 0.6 }, // Mid clouds
                                { count: 15, height: 100, speed: 0.1, spread: 25, size: 2, opacity: 0.5 }    // Low clouds
                            ];
                            
                            clouds = []; // Reset clouds array
                            
                            cloudLayers.forEach(layer => {
                                for (let i = 0; i < layer.count; i++) {
                                    const cloudGroup = new THREE.Group();
                                    const particleCount = 80 + Math.random() * 60;
                                    
                                    // Create particle geometry with varying sizes
                                    const particleGeometry = new THREE.SphereGeometry(layer.size, 8, 8);
                                    const particleMaterial = new THREE.MeshStandardMaterial({
                                        color: 0xFFFFFF,
                                        transparent: true,
                                        opacity: layer.opacity,
                                        roughness: 0.1,
                                        metalness: 0.0
                                    });

                                    // Random cloud position with layer-specific height
                                    const cloudX = (Math.random() - 0.5) * 1800;
                                    const cloudZ = (Math.random() - 0.5) * 1800;
                                    const cloudY = layer.height + (Math.random() - 0.5) * 20;

                                    // Create particles with natural distribution
                                    for (let j = 0; j < particleCount; j++) {
                                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                                        
                                        // Use gaussian-like distribution for more natural cloud shape
                                        const angle = Math.random() * Math.PI * 2;
                                        const distance = Math.random() * layer.spread;
                                        const xOffset = Math.cos(angle) * distance;
                                        const zOffset = Math.sin(angle) * distance;
                                        
                                        particle.position.set(
                                            cloudX + xOffset,
                                            cloudY + (Math.random() - 0.5) * 8,
                                            cloudZ + zOffset
                                        );
                                        
                                        // Random rotation for variety
                                        particle.rotation.x = Math.random() * Math.PI;
                                        particle.rotation.y = Math.random() * Math.PI;
                                        
                                        cloudGroup.add(particle);
                                    }

                                    // Add cloud movement properties with layer-specific behavior
                                    cloudGroup.userData = {
                                        speed: layer.speed + (Math.random() - 0.5) * 0.02,
                                        direction: new THREE.Vector3(
                                            Math.random() - 0.5,
                                            0,
                                            Math.random() - 0.5
                                        ).normalize(),
                                        bounds: 900,
                                        layer: layer,
                                        timeOffset: Math.random() * Math.PI * 2 // For wave motion
                                    };

                                    clouds.push(cloudGroup);
                                    scene.add(cloudGroup);
                                }
                            });

                            // Enhanced terrain generation
                            vertices = geometry.attributes.position.array;
                            
                            for (let i = 0; i < vertices.length; i += 3) {
                                const x = vertices[i];
                                const z = vertices[i + 2];
                                
                                // Multiple layers of noise for more natural terrain
                                const baseNoise = (
                                    Math.sin(x * 0.02) * Math.cos(z * 0.02) * 15 +
                                    Math.sin(x * 0.05) * Math.cos(z * 0.05) * 5 +
                                    Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2
                                );

                                const ridgeNoise = Math.abs(
                                    Math.sin(x * 0.01 + z * 0.01) * 
                                    Math.cos(x * 0.02 - z * 0.02)
                                ) * 50;

                                const detailNoise = (
                                    Math.sin(x * 0.2) * Math.cos(z * 0.2) * 1 +
                                    Math.sin(x * 0.4) * Math.cos(z * 0.4) * 0.5
                                );

                                const mountainNoise = Math.pow(
                                    Math.abs(Math.sin(x * 0.005) * Math.cos(z * 0.005)), 
                                    1.5
                                ) * 120;

                                // Combine noise layers
                                let height = baseNoise;
                                height += ridgeNoise * Math.pow(Math.abs(Math.sin(x * 0.01)), 2);
                                height += detailNoise;
                                height += mountainNoise;

                                // Apply height
                                vertices[i + 1] = height;
                            }

                            geometry.computeVertexNormals();

                            // Enhanced ground material with better shadow reception
                            const groundMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x639544,
                                roughness: 0.8,
                                metalness: 0.1,
                                map: grassTexture,
                                normalMap: grassNormal,
                                normalScale: new THREE.Vector2(2, 2),
                                flatShading: false
                            });

                            terrain = new THREE.Mesh(geometry, groundMaterial);
                            terrain.receiveShadow = true;
                            terrain.castShadow = true;
                            scene.add(terrain);

                            updateProgress(85, "Adding world objects...");

                            // Create world objects with all varieties
                            const worldObjects = [
                                { type: 'tallTree', count: 150, minDist: 20, maxDist: 800 },
                                { type: 'deadTree', count: 100, minDist: 30, maxDist: 700 },
                                { type: 'wideTree', count: 120, minDist: 25, maxDist: 750 },
                                { type: 'palmTree', count: 80, minDist: 40, maxDist: 600 },
                                { type: 'boulder', count: 100, minDist: 15, maxDist: 900 },
                                { type: 'crystal', count: 40, minDist: 50, maxDist: 800 },
                                { type: 'mushroom', count: 60, minDist: 10, maxDist: 400 }
                            ];

                            // Create world objects with improved distribution
                            worldObjects.forEach(objType => {
                                console.log("Generating " + objType.count + " " + objType.type + "s...");
                                for (let i = 0; i < objType.count; i++) {
                                    // Use multiple angles for better distribution
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = objType.minDist + Math.random() * (objType.maxDist - objType.minDist);
                                    
                                    // Calculate position with some randomness
                                    const x = Math.cos(angle) * distance + (Math.random() - 0.5) * 20;
                                    const z = Math.sin(angle) * distance + (Math.random() - 0.5) * 20;
                                    
                                    // Create the object
                                    createWorldObject(objType.type, x, z);
                                }
                            });

                            updateProgress(90, "Adding NPCs...");

                            // Add NPCs with their buildings
                            const npcLocations = [
                                { x: 20, z: 20, type: 'jedi' },      // Blue Jedi
                                { x: -30, z: 40, type: 'rebel' },    // Red Rebel
                                { x: 50, z: -20, type: 'merchant' }, // Orange Merchant
                                { x: -40, z: -50, type: 'droid' }    // Silver Droid
                            ];

                            npcLocations.forEach(loc => {
                                // Create building first
                                createWorldObject('westernBuilding', loc.x, loc.z);
                                // Create NPC slightly in front of building
                                createWorldObject('npc', loc.x + 3, loc.z + 3, loc.type);
                            });

                            // Event listeners
                            window.addEventListener('resize', onWindowResize, false);
                            document.addEventListener('keydown', onKeyDown);
                            document.addEventListener('keyup', onKeyUp);
                            
                            // Create character controller (for reference only, not used in this file)
                            try {
                                console.log("Initializing character controller...");
                                const characterController = new CharacterController({
                                    camera: camera,
                                    character: character,
                                    terrain: terrain,
                                    vertices: vertices,
                                    controls: controls,
                                    characterHeight: characterHeight,
                                    moveSpeed: moveSpeed,
                                    jumpForce: jumpForce,
                                    maxJumps: maxJumps,
                                    terrainSize: 2000,
                                    terrainSegments: 128
                                });
                                console.log("Character controller initialized successfully!");
                            } catch (error) {
                                console.error("Error initializing character controller:", error);
                                // Continue anyway since this might not be critical
                            }
                            
                            updateProgress(100, "Ready to play!");
                            
                            // Hide loading screen with a slight delay to ensure everything is ready
                            setTimeout(function() {
                                try {
                                    if (loadingScreen) {
                                        loadingScreen.style.display = 'none';
                                        console.log("Loading screen hidden, game ready!");
                                    }
                                } catch (error) {
                                    console.error("Error hiding loading screen:", error);
                                }
                            }, 1000);
                        }

                        // Update cloud update function for more realistic movement
                        function updateClouds() {
                            const time = performance.now() * 0.001; // Convert to seconds
                            
                            clouds.forEach(cloud => {
                                // Add subtle wave motion
                                const waveMotion = Math.sin(time + cloud.userData.timeOffset) * 0.5;
                                cloud.position.y = cloud.userData.layer.height + waveMotion;
                                
                                // Create movement vector for this frame
                                const movement = cloud.userData.direction.clone().multiplyScalar(cloud.userData.speed);
                                
                                // Move cloud with layer-specific speed
                                cloud.position.add(movement);
                                
                                // Reset cloud position if it goes too far
                                if (cloud.position.length() > cloud.userData.bounds) {
                                    // Calculate new position with smooth transition
                                    const newX = (Math.random() - 0.5) * 1800;
                                    const newZ = (Math.random() - 0.5) * 1800;
                                    
                                    // Reset position
                                    cloud.position.set(
                                        newX,
                                        cloud.userData.layer.height + waveMotion,
                                        newZ
                                    );
                                    
                                    // Update direction with slight randomness
                                    const newDirection = new THREE.Vector3(
                                        Math.random() - 0.5,
                                        0,
                                        Math.random() - 0.5
                                    ).normalize();
                                    
                                    cloud.userData.direction.copy(newDirection);
                                    
                                    // Update speed with slight variation while maintaining base speed
                                    cloud.userData.speed = cloud.userData.layer.speed * (0.8 + Math.random() * 0.4);
                                }
                                
                                // Add subtle rotation to cloud particles
                                cloud.children.forEach(particle => {
                                    particle.rotation.y += 0.001;
                                });
                            });
                        }

                        function onWindowResize() {
                            camera.aspect = window.innerWidth / window.innerHeight;
                            camera.updateProjectionMatrix();
                            renderer.setSize(window.innerWidth, window.innerHeight);
                        }

                        function animate() {
                            requestAnimationFrame(animate);
                            
                            // Update clouds regardless of controls state
                            updateClouds();

                            if (controls.isLocked) {
                                const time = performance.now();
                                const delta = Math.min((time - prevTime) / 1000, 0.1);
                                
                                // Handle gamepad input first
                                handleGamepad(delta);
                                
                                // Move sun position for dynamic shadows
                                const sunAngle = time * 0.00005;
                                const sunOrbitRadius = 1500;
                                const sunHeight = 1000;
                                
                                // Update directional light position
                                sun.position.x = Math.cos(sunAngle) * sunOrbitRadius;
                                sun.position.z = Math.sin(sunAngle) * sunOrbitRadius;
                                sun.position.y = sunHeight + Math.sin(sunAngle) * 200;
                                
                                // Update sun target and ensure it's looking at the center
                                sun.target.position.set(0, 0, 0);
                                sun.lookAt(0, 0, 0);
                                
                                // Update sun sphere position to match light
                                sunSphere.position.copy(sun.position);
                                
                                // Make sun flare always face camera
                                if (window.sunFlare) {
                                    window.sunFlare.lookAt(camera.position);
                                }
                                
                                // Update sun glow
                                const glowPulse = Math.sin(time * 0.001) * 0.1 + 0.9;
                                sunGlow.scale.set(glowPulse, glowPulse, glowPulse);

                                // Improved terrain collision detection
                                const terrainY = getHeightAt(camera.position.x, camera.position.z);
                                
                                // Apply gravity and terrain collision with improved detection
                                if (camera.position.y > terrainY + characterHeight + 0.1) {
                                    velocity.y -= 9.8 * 10.0 * delta;
                                } else if (camera.position.y < terrainY + characterHeight) {
                                    camera.position.y = terrainY + characterHeight;
                                    velocity.y = 0;
                                    jumpCount = 0;
                                } else {
                                    velocity.y = 0;
                                    jumpCount = 0;
                                }

                                // Calculate keyboard movement direction
                                direction.z = Number(moveForward) - Number(moveBackward);
                                direction.x = Number(moveRight) - Number(moveLeft);
                                direction.normalize();

                                // Apply keyboard movement
                                if (moveForward || moveBackward || moveLeft || moveRight) {
                                    // Get camera direction
                                    const cameraDirection = new THREE.Vector3();
                                    camera.getWorldDirection(cameraDirection);
                                    cameraDirection.y = 0; // Keep movement on the horizontal plane
                                    cameraDirection.normalize();
                                    
                                    // Get camera right vector
                                    const cameraRight = new THREE.Vector3(-cameraDirection.z, 0, cameraDirection.x);
                                    
                                    // Calculate movement vector based on camera orientation
                                    const moveVector = new THREE.Vector3();
                                    
                                    if (moveForward) {
                                        moveVector.add(cameraDirection);
                                    }
                                    if (moveBackward) {
                                        moveVector.sub(cameraDirection);
                                    }
                                    if (moveRight) {
                                        moveVector.add(cameraRight);
                                    }
                                    if (moveLeft) {
                                        moveVector.sub(cameraRight);
                                    }
                                    
                                    // Normalize and scale by speed
                                    if (moveVector.length() > 0) {
                                        moveVector.normalize().multiplyScalar(moveSpeed * delta);
                                        
                                        // Apply movement directly to camera position
                                        camera.position.x += moveVector.x;
                                        camera.position.z += moveVector.z;
                                        
                                        // Update character rotation to face movement direction
                                        const targetAngle = Math.atan2(moveVector.x, moveVector.z);
                                        const currentAngle = character.rotation.y;
                                        character.rotation.y = currentAngle + (targetAngle - currentAngle) * 0.15;
                                    }
                                }

                                // Apply vertical movement (jumping/falling)
                                camera.position.y += velocity.y * delta;
                                
                                // Additional terrain collision check after movement
                                const newTerrainY = getHeightAt(camera.position.x, camera.position.z);
                                if (camera.position.y < newTerrainY + characterHeight) {
                                    camera.position.y = newTerrainY + characterHeight;
                                }

                                // Update character mesh position
                                character.position.x = camera.position.x;
                                character.position.z = camera.position.z;
                                character.position.y = camera.position.y - 2;
                                
                                // Reset velocity for next frame
                                velocity.x = 0;
                                velocity.z = 0;
                                
                                prevTime = time;

                                renderer.render(scene, camera);
                            }
                        }

                        // Movement variables
                        let moveForward = false;
                        let moveBackward = false;
                        let moveLeft = false;
                        let moveRight = false;

                        function onKeyDown(event) {
                            switch (event.code) {
                                case 'ArrowUp':
                                case 'KeyW':
                                    moveForward = true;
                                    break;
                                case 'ArrowDown':
                                case 'KeyS':
                                    moveBackward = true;
                                    break;
                                case 'ArrowLeft':
                                case 'KeyA':
                                    moveLeft = true;
                                    break;
                                case 'ArrowRight':
                                case 'KeyD':
                                    moveRight = true;
                                    break;
                                case 'Space':
                                    if (isOnGround()) {
                                        velocity.y = jumpForce;
                                        jumpCount = 1;
                                    } else if (jumpCount < maxJumps) {
                                        velocity.y = jumpForce;
                                        jumpCount++;
                                    }
                                    break;
                            }
                        }

                        function onKeyUp(event) {
                            switch (event.code) {
                                case 'ArrowUp':
                                case 'KeyW':
                                    moveForward = false;
                                    break;
                                case 'ArrowDown':
                                case 'KeyS':
                                    moveBackward = false;
                                    break;
                                case 'ArrowLeft':
                                case 'KeyA':
                                    moveLeft = false;
                                    break;
                                case 'ArrowRight':
                                case 'KeyD':
                                    moveRight = false;
                                    break;
                            }
                        }
                    `;
                    document.body.appendChild(gameScript);
                }, 500);
            };
        };
    </script>
</body>
</html> 